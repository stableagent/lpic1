# 101.2 راه اندازی (Boot) سیستم

### 101.2. راه اندازی (Boot) سیستم

**وزن:** 3

**توضیحات:** داوطلبان باید قادر باشند سیستم را در فرآیند راه‌اندازی (booting) هدایت کنند.

**حوزه‌های کلیدی دانش:**

* ارائه دستورات رایج به boot loader و گزینه‌ها به kernel در زمان boot
* نمایش دانش در مورد توالی boot از BIOS تا تکمیل boot
* درک SysVinit و systemd
* آگاهی از Upstart
* بررسی رویدادهای boot در فایل‌های log

**اصطلاحات و ابزارهای کاربردی:**

* dmesg
* BIOS
* bootloader
* kernel
* initramfs
* init
* SysVinit
* systemd

آیا تا به حال فکر کرده‌اید که وقتی دکمه روشن/خاموش (power) را روی یک کامپیوتر یا لپ‌تاپ فشار می‌دهید، چه اتفاقی می‌افتد؟ هیچ جن یا روحی وجود ندارد که قلب فلزی مرده را روشن کند و سیستم‌عامل را بالا آورده و اجرا کند. بیایید ببینیم چگونه این اتفاق می‌افتد؟

## فرآیند Boot

بیایید یک تصویر بزرگ ترسیم کنیم تا نمای کلی از فرآیند عمومی boot از BIOS تا shell داشته باشیم.

![](.gitbook/assets/boot-bootseq.jpg)

اکنون بیایید هر یک از این مراحل را بیشتر توضیح دهیم:

**1-** ابتدا سیستم روشن می‌شود.

**2-** بارگذاری BIOS (در سیستم‌های مدرن، UEFI خواهد بود)

## BIOS

BIOS، که مخفف Basic Input Output System است، نرم‌افزاری است که روی یک تراشه حافظه کوچک روی مادربرد ذخیره شده است. BIOS مسئول POST است. POST که مخفف Power On Self Test است، مجموعه اولیه‌ای از تست‌های تشخیصی است که توسط کامپیوتر بلافاصله پس از روشن شدن، با هدف بررسی هرگونه مشکل مرتبط با سخت‌افزار انجام می‌شود. بنابراین BIOS باعث می‌شود POST اولین نرم‌افزاری باشد که هنگام روشن شدن کامپیوتر اجرا می‌شود.

![](.gitbook/assets/boot-bios.jpg)

**3-** BIOS اسکن کرده و به سراغ "boot sector" دیسک اصلی (یا انتخاب شده) می‌رود. یک boot sector منطقه‌ای از هارد دیسک، فلاپی دیسک، دیسک نوری یا سایر دستگاه‌های ذخیره‌سازی داده است که شامل کد ماشین برای بارگذاری در حافظه دسترسی تصادفی (RAM) توسط سیستم‌عامل داخلی کامپیوتر مانند BIOS است.

در boot sector چه چیزی وجود دارد؟ MBR

## MBR

رکورد راه انداز اصلی (Master Boot Record که اغلب به اختصار MBR نامیده می‌شود) نوعی boot sector است که روی هارد دیسک یا سایر دستگاه‌های ذخیره‌سازی ذخیره می‌شود و حاوی کد کامپیوتری لازم برای شروع فرآیند boot است.

MBR در اولین سکتور (sector) یک دیسک قرار دارد. آدرس دقیق روی دیسک Cylinder: 0، Head: 0، Sector: 1 است و حجم آن 512 بایت است.

Master Boot Record شامل چه چیزهایی است و چگونه توالی boot را ادامه می‌دهد؟

![](.gitbook/assets/boot-MBR.JPG)

Master Boot Record خود دو چیز را نگه می‌دارد: برنامه boot loader (یا بخشی از آن) و جدول پارتیشن (partition table).

هنگامی که BIOS بارگذاری می‌شود، به دنبال داده‌های ذخیره شده در اولین سکتور هارد درایو، یعنی MBR می‌گردد؛ با استفاده از داده‌های ذخیره شده در MBR، BIOS برنامه boot loader را فعال می‌کند.

{% hint style="info" %}
عدد جادویی (Magic Number) چیست؟ این بخش که در دو بایت آخر **MBR** (511-512) قرار دارد، باید حاوی مقدار هگزادسیمال AA55 باشد که رسماً آن را به عنوان یک **MBR** معتبر طبقه‌بندی می‌کند. یک **magic number** نامعتبر نشان‌دهنده یک **MBR** خراب یا مفقود است، بنابراین این بایت‌ها برای boot کردن یا استفاده از دیسک حیاتی هستند.
{% endhint %}

**4-** Boot Loader اجرا می‌شود.

### Boot Loader

به زبان ساده، یک boot loader سیستم‌عامل را بارگذاری می‌کند. اکثر boot loaderها در دو مرحله بارگذاری می‌شوند.

**A-** در اولین مرحله boot، BIOS بخشی از boot loader را بارگذاری می‌کند که به عنوان **initial program loader** یا **IPL** شناخته می‌شود. **IPL** **جدول پارتیشن (partition table) را بررسی کرده و متعاقباً قادر است داده‌ها را از هر کجایی که روی رسانه‌های مختلف وجود دارند بارگذاری کند.** این عمل در ابتدا برای مکان‌یابی مرحله دوم boot loader استفاده می‌شود که بقیه loader را نگه می‌دارد.

**B-** مرحله دوم boot loader بخش اصلی boot loader است؛ بسیاری آن را تنها بخش واقعی boot loader می‌دانند. این بخش حاوی بخش‌های **با استفاده سنگین از دیسک (disk-intensive)** loader است، مانند رابط‌های کاربری \[bootloader] و kernel loaders. (این رابط‌های کاربری می‌توانند از یک خط فرمان ساده تا GUIهای مدرن متغیر باشند.)

**5-** Lilo / Grub / Grub2 آغاز می‌شوند.

تاکنون boot loaderهای مختلفی وجود داشته‌اند: Lilo، Grub و Grub2:

## Lilo

LILO (Linux Loader) یک boot loader برای Linux است و در سال‌های پس از محبوبیت loadlin، boot loader پیش‌فرض برای اکثر توزیع‌های لینوکس بود. امروزه، بسیاری از توزیع‌ها از GRUB به عنوان boot loader پیش‌فرض استفاده می‌کنند، اما LILO و نوع دیگر آن ELILO هنوز به طور گسترده مورد استفاده قرار می‌گیرند. توسعه بیشتر LILO در دسامبر 2015 به همراه درخواستی از سوی Joachim Wiedorn برای توسعه‌دهندگان احتمالی متوقف شد.

![](.gitbook/assets/boot-lilo.jpg)

فایل پیکربندی lilo در آدرس “/etc/lilo.conf” قرار دارد. Lilo این فایل پیکربندی را می‌خواند و این فایل به Lilo می‌گوید که bootloader را در کجا قرار دهد. نمونه‌ای از فایل پیکربندی در زیر مشخص شده است:

```
boot=/dev/hda              # This tells LILO where to install the bootloader.
map=/boot/map              # This file is automatically generated by LILO during bootup
install=/boot/boot.b       # This file contains the “bootstrap” code that starts your operating system and it holds both the primary and secondary parts of the bootloader.
prompt                     # This tells LILO to use the user interface. For example, to choose an operating system or enter parameters for the Linux kernel.
timeout=50                 # Tells LILO how long to wait at the prompt before booting the default operating system.
image=/boot/vmlinuz-2.0.36 # Name of a Linux kernel for LILO to boot.
label                      # specifies the default OS to boot.
root=/dev/hda2             # This option tells LILO where the OS file system actually lives.
read-only                  # This tells LILO to perform the initial boot to the file system read-only.
other=/dev/hda1            # It tells LILO to boot an operating system other than Linux.
label=win                  # same as all other label options.
```

lilo به عنوان یک دستور (command) گزینه‌هایی دارد که ممکن است مفید باشند:

```
 -c config-file: Specifies the alternative configuration file other than default file /etc/lilo.conf.
 -q: Lists the mapped files.
 -V: Prints the Lilo version number.
 -v: Specifies verbose output.
 -u device-name: Uninstalls LILO and restores the saved boot sector after validating timestamp. Device-name is the name of the device on which LILO is installed.
 -U device-name: This is the same as -u, but it does not check the timestamp.
 -R command-line: Sets the default command for the boot loader the next time it executes.
```

## Grub

GRUB (GRand Unified Bootloader) یک پکیج boot loader است که برای پشتیبانی از چندین سیستم‌عامل توسعه یافته و به کاربر اجازه می‌دهد در حین boot-up یکی از آن‌ها را انتخاب کند. این پکیج تحت پروژه GNU با نام GNU GRUB توسعه یافته است.

## Grub2

اکنون GRUB 2 جایگزین GRUB شده است. و نام GRUB به GRUB Legacy تغییر یافت و دیگر به طور فعال توسعه نمی‌یابد، با این حال، می‌توان از آن برای boot کردن سیستم‌های قدیمی‌تر استفاده کرد زیرا رفع باگ‌های آن هنوز ادامه دارد.

در ظاهر، اکثریت کاربران متوجه هیچ تفاوتی نخواهند شد، اما نسخه جدید دارای تغییرات ساختاری عمده‌ای است و باید قابل اعتمادتر باشد. همچنین نسخه جدید فایل‌های پیکربندی خود را به طور متفاوتی ذخیره می‌کند.

بهبودهای عمده GRUB 2 نسبت به GRUB اصلی عبارتند از:

* پشتیبانی از multiboot
* پشتیبانی از معماری‌های سخت‌افزاری و سیستم‌عامل‌های مختلف مانند Linux و Windows
* ارائه رابط خط فرمان تعاملی مشابه Bash برای کاربران جهت اجرای دستورات GRUB و همچنین تعامل با فایل‌های پیکربندی
* امکان دسترسی به ویرایشگر GRUB
* پشتیبانی از تنظیم رمز عبور با رمزنگاری برای امنیت
* پشتیبانی از boot از طریق شبکه به همراه چندین ویژگی جزئی دیگر

صرف نظر از نسخه GRUB، یک boot loader به کاربر اجازه می‌دهد:

1. با تعیین kernelهای مختلف برای استفاده، نحوه رفتار سیستم را اصلاح کند،
2. بین سیستم‌عامل‌های جایگزین برای boot انتخاب کند، و
3. خطوط پیکربندی را برای تغییر گزینه‌های boot، در میان موارد دیگر، اضافه یا ویرایش کند.

## گزینه‌های زمان Boot هسته (Kernel boot-time Options)

پارامترهای خط فرمان Kernel پارامترهایی هستند که در طول فرآیند boot به سیستم منتقل می‌کنیم. آن‌ها به عنوان "boot options" نیز شناخته می‌شوند.

ما **باید در کنسول (console) باشیم** تا دستورات زمان boot هسته را ارسال کنیم، زیرا وقتی سیستم در حال بالا آمدن است، هیچ سرویس شبکه‌ای (Networking) وجود ندارد. بنابراین سیستم را ری‌بوت (reboot) کرده و کلید Esc را در طول boot فشار دهید:

![](.gitbook/assets/boot-grubmenu.jpg)

بسته به پیکربندی، کاربر ممکن است بتواند از منویی از انواع boot بالقوه یا نسخه‌های kernel انتخاب کند یا به سادگی اجازه دهد حالت پیش‌فرض ادامه یابد. بیایید کلید 'e' را فشار دهیم تا برخی از پارامترهای kernel را ببینیم:

![](.gitbook/assets/boot-grubmenu2.jpg)

پارامترهای boot مربوط به Linux Kernel به صورت لیستی از رشته‌ها که با فواصل (white spaces) از هم جدا شده‌اند، منتقل می‌شوند:

```
name[=value_1] [,value_2]........[,value_10]
```

که در آن ‘**name=unique keyword**‘ بخش **kernel** را که قرار است مقدار با آن مرتبط شود، تعریف می‌کند. (حداکثر 10)

`'linux'` مکان فایل اجرایی هسته (vmlinuz/vmlinux) را برای اجرا تعریف می‌کند و مشخصاً گزینه‌های boot هسته بعد از آن می‌آیند.

پارامترهای زیادی وجود دارند که به ما در پیکربندی و تعیین تمام جنبه‌های عملیات سیستم در طول فرآیند boot کمک می‌کنند. برخی از آن‌ها عبارتند از:

```
root=UUID=... : This argument tells the kernel what device (hard disk, floppy disk) to be used as the root filesystem while booting.
ro : This argument tells the kernel to mount root file system as read-only.
```

یکی از مشهورترین گزینه‌های boot هسته، بازیابی رمز عبور با استفاده از پارامتر `single` است. پارامتر `single` به ‘init‘ دستور می‌دهد تا کامپیوتر را در حالت تک کاربره (single user mode) راه‌اندازی کرده و اجرای تمام daemonها را غیرفعال کند.

`/proc/cmdline` این فایل پارامترهای ارسال شده به kernel را در زمان شروع آن نشان می‌دهد:

```
root@server2:~# cat /proc/cmdline 
BOOT_IMAGE=/boot/vmlinuz-4.10.0-28-generic root=UUID=e4a2c83b-fb68-46f5-a7ec-a83bbad6e3fd ro find_preseed=/preseed.cfg auto noprompt priority=critical locale=en_US quiet
```

**6-** Linux Kernel خوانده و اجرا می‌شود. 

{% hint style="info" %}
به محض اینکه هسته Linux بوت شد و سیستم‌فایل ریشه (/) mount شد، برنامه‌ها می‌توانند اجرا شوند و ماژول‌های هسته بیشتری برای ارائه عملکردهای اضافی ادغام شوند. 

برای mount کردن سیستم‌فایل ریشه، باید شرایط خاصی رعایت شود. هسته برای دسترسی به دستگاهی که سیستم‌فایل ریشه روی آن قرار دارد (به ویژه درایورهای SCSI) به درایورهای مربوطه نیاز دارد. هسته همچنین باید حاوی کد مورد نیاز برای خواندن سیستم‌فایل (ext2، reiserfs، romfs و غیره) باشد. همچنین ممکن است سیستم‌فایل ریشه از قبل رمزنگاری شده باشد. در این صورت، برای mount کردن سیستم‌فایل به رمز عبور نیاز است.

دیسک رم اولیه (Initial RAM disk که initdisk یا initrd نیز نامیده می‌شود) دقیقاً مشکلات توصیف شده در بالا را حل می‌کند.
{% endhint %}

## initramfs

هسته Linux گزینه‌ای برای داشتن یک سیستم‌فایل کوچک بارگذاری شده در یک RAM disk و اجرای برنامه‌ها در آنجا قبل از mount شدن سیستم‌فایل ریشه واقعی فراهم می‌کند. 

The initrd contains a minimal set of directories and executables to achieve this, such as the `insmod` tool to install kernel modules into the kernel.

طول عمر آن کوتاه است و فقط به عنوان پلی برای سیستم‌فایل ریشه واقعی عمل می‌کند. 

**7- **برنامه 'init' بارگذاری شده و به اولین ID فرآیند (process ID) تبدیل می‌شود.

### init چیست؟

در Linux، کلمه init مخفف Initialization است. init یک فرآیند daemon است که به محض شروع به کار کامپیوتر آغاز می‌شود و تا زمان خاموش شدن (shutdown) به کار خود ادامه می‌دهد. در واقع init اولین فرآیندی است که هنگام بوت شدن کامپیوتر شروع می‌شود و آن را به والد تمام فرآیندهای در حال اجرای دیگر به طور مستقیم یا غیرمستقیم تبدیل می‌کند و از این رو معمولاً “pid=1“ به آن اختصاص می‌یابد.
'init' در توزیع‌های قبلی لینوکس فرآیندی با نام /sbin/init بود. امروزه 'init' دیگر 'init' نیست، بلکه می‌تواند هر چیزی باشد.

## راهکارهای برنامه init

در دنیای لینوکس ما سه نوع مختلف از برنامه‌های init داریم که daemonها، برنامه‌های کاربردی (applications) و برنامه‌های مختلف را اجرا می‌کنند.

* SysV
* upstart
* Systemd

بنابراین /sbin/init می‌تواند به upstart یا systemd لینک شده باشد.

**Sysv**

SysV سیستمی بسیار قدیمی‌تر برای مدیریت شروع به کار سرویس‌ها در طول فرآیند boot در یک سیستم Linux است. SysVinit تقریباً از همیشه وجود داشته است. به طور سنتی در SystemV، از فرآیند /sbin/init برای شروع سرویس‌ها استفاده می‌شد.

روشی که SysVinit این کار را انجام می‌دهد، تعیین یک ترتیب دقیق برای شروع سرویس‌ها است. به هر سرویس یک شماره اولویت اختصاص داده می‌شود و init سرویس‌ها را به ترتیب اولویت شروع می‌کند.

ترتیبی که در آن این اتفاق می‌افتد ضروری است، بارگذاری سریال برای وابستگی‌ها مورد نیاز است، اما گاهی اوقات می‌توان از بارگذاری موازی برای افزایش سرعت استفاده کرد. مشکل SysVinit این است که نیاز به تنظیم دقیق دارد، هر دو upstart و Systemd برای کارآمدتر کردن بارگذاری پیکربندی‌های سیستم توسعه یافته‌اند.

```
### CentOS 5
```

**Upstart**

در تلاش برای آوردن ویژگی‌های بیشتر به فرآیند مقداردهی اولیه (initialization) لینوکس، Canonical توزیع Ubuntu 6.10 (Edgy Eft) را در سال 2006 با Upstart منتشر کرد. Upstart از ابتدا با قابلیت سازگاری عقب‌رو (backward compatibility) طراحی شد. این سیستم می‌توانست daemonها را بدون هیچ تغییری در اسکریپت‌های راه‌اندازی اجرا کند. به همین دلیل، بسیاری از توزیع‌های لینوکس به سمت Upstart رفتند، اما نه همه آن‌ها.

Upstart یک جایگزین رویداد-محور (event-based) است، رویدادها را دریافت کرده و سپس کارها را بر اساس این رویدادها اجرا می‌کند.

مشکل upstart این است که از shell scriptها و بسیاری از ویژگی‌هایی که قبلاً در init وجود داشت استفاده می‌کند. بنابراین اگرچه سازگاری عقب‌رو دارد اما از تکیه بر کدهای نامنظم رنج می‌برد.

> اگر سیستم ما دارای دایرکتوری /etc/init باشد، از upstart استفاده می‌کند.

```
### Ubuntu 14
root@ubuntu:~# ls /etc/init
init/            init.d/          initramfs-tools/
```

**Systemd**

{% hint style="info" %}
یک systemd، ممکن است به تمام پکیج‌ها، ابزارها و کتابخانه‌های پیرامون daemon اشاره داشته باشد. هدف پروژه systemd ارائه سیستم‌عاملی است که روی هسته لینوکس اجرا می‌شود و تقریباً همه چیز را پس از بارگذاری هسته تحت کنترل می‌گیرد. در نتیجه، برای غلبه بر کاستی‌های init توسعه یافته است.
{% endhint %}

Systemd برای شروع فرآیندها به صورت موازی طراحی شده است، بنابراین زمان boot و بار محاسباتی را کاهش می‌دهد. این سیستم در مقایسه با init ویژگی‌های بسیار دیگری دارد.

Systemd به سرعت در حال تسخیر نحوه شروع سرویس‌ها در سیستم‌های لینوکس است و استاندارد فعلی در تمام توزیع‌های اصلی لینوکس (حتی Ubuntu) است. Systemd سازگاری عقب‌رو ندارد، اما اسکریپت‌های زیادی وجود دارند که دستورات sysv را به دستورات systemd تبدیل می‌کنند و به شما اجازه می‌دهند احساس راحتی کنید.

> اگر سیستم ما دارای دایرکتوری /usr/lib/systemd باشد، ما روی systemd هستیم.

```
### Ubuntu 16 or CentOS 7
root@ubuntu16-1:~# ls /usr/lib/systemd
boot  catalog  network  user  user-generators
```

**8-** Sysv یا upstart یا systemd (هر کدام که مدیریت سرویس سیستم شما باشد) همه چیز را شروع می‌کند. پیش‌نیازها، سرویس‌ها، ... و shell. و زمانی که shell حاضر شد، کاربر می‌تواند وارد سیستم (log in) شود.

## dmesg

دستور dmesg برای **نمایش پیام‌های مرتبط با هسته (kernel)** در سیستم‌های شبه یونیکس استفاده می‌شود. dmesg مخفف “display message” یا “display driver” است. دستور dmesg داده‌های خود را با خواندن kernel ring buffer بازیابی می‌کند.

kernel ring buffer یک ساختار داده است که پیام‌های مربوط به عملکرد هسته را ضبط می‌کند. ring buffer نوع خاصی از بافر است که همیشه اندازه ثابتی دارد و با آمدن پیام‌های جدید، پیام‌های قدیمی را حذف می‌کند.

![](.gitbook/assets/boot-dmesgkrb.png)

dmesg می‌تواند هنگام عیب‌یابی (troubleshooting) یا صرفاً برای به دست آوردن اطلاعات در مورد سخت‌افزار یک سیستم بسیار مفید باشد. سینتکس اصلی آن dmesg \[options] است.

```
Options:
 -C, --clear                 clear the kernel ring buffer
 -c, --read-clear            read and clear all messages
 -D, --console-off           disable printing messages to console
 -E, --console-on            enable printing messages to console
 -F, --file <file>           use the file instead of the kernel log buffer
 -f, --facility <list>       restrict output to defined facilities
 -H, --human                 human readable output
 -k, --kernel                display kernel messages
 -L, --color[=<when>]        colorize messages (auto, always or never)
                                colors are enabled by default
 -l, --level <list>          restrict output to defined levels
 -n, --console-level <level> set level of messages printed to console
 -P, --nopager               do not pipe output into a pager
 -r, --raw                   print the raw message buffer
 -S, --syslog                force to use syslog(2) rather than /dev/kmsg
 -s, --buffer-size <size>    buffer size to query the kernel ring buffer
 -u, --userspace             display userspace messages
 -w, --follow                wait for new messages
 -x, --decode                decode facility and level to readable string
 -d, --show-delta            show time delta between printed messages
 -e, --reltime               show local time and time delta in readable format
 -T, --ctime                 show human readable timestamp (may be inaccurate!)
 -t, --notime                don't print messages timestamp
     --time-format <format>  show time stamp using format:
                                [delta|reltime|ctime|notime|iso]
```

استفاده از dmesg بدون هیچ یک از گزینه‌های آن باعث می‌شود تمام پیام‌های هسته را در خروجی استاندارد بنویسد. 

```
root@ubuntu16-1:~# dmesg 

<Output has been truncated>

[    6.126297] audit: type=1400 audit(1541417236.033:9): apparmor="STATUS" operation="profile_load" profile="unconfined" name="/usr/bin/evince//sanitized_helper" pid=603 comm="apparmor_parser"
[    6.126298] audit: type=1400 audit(1541417236.033:10): apparmor="STATUS" operation="profile_load" profile="unconfined" name="/usr/bin/evince-previewer" pid=603 comm="apparmor_parser"
[    6.403014] shpchp: Standard Hot Plug PCI Controller Driver version: 0.4
[    6.403138] piix4_smbus 0000:00:07.3: SMBus Host Controller not enabled!
[    6.450506] vmw_vmci 0000:00:07.7: Found VMCI PCI device at 0x11080, irq 16
[    6.450585] vmw_vmci 0000:00:07.7: Using capabilities 0xc
[    6.481197] Guest personality initialized and is active
[    6.481237] VMCI host device registered (name=vmci, major=10, minor=55)
[    6.481238] Initialized host personality
[    6.861468] random: crng init done
[    6.870993] AVX2 version of gcm_enc/dec engaged.
[    6.870994] AES CTR mode by8 optimization enabled
[    7.412248] Adding 1045500k swap on /dev/sda5.  Priority:-1 extents:1 across:1045500k FS
[    9.011802] IPv6: ADDRCONF(NETDEV_UP): ens33: link is not ready
[    9.019995] e1000: ens33 NIC Link is Up 1000 Mbps Full Duplex, Flow Control: None
[    9.315344] floppy0: no floppy controllers found
[    9.315374] work still pending
[   10.229508] ip_tables: (C) 2000-2006 Netfilter Core Team
[   13.740999] NET: Registered protocol family 40
```

در صورت نیاز می‌توانیم لاگ‌های dmesg را با دستور `dmesg -c` پاک کنیم.

**/var/log/dmesg**

دستور `dmesg` محتوای فعلی پیام‌های kernel syslog ring buffer را نشان می‌دهد، در حالی که فایل `/var/log/dmesg` حاوی چیزی است که در آن ring buffer در آخرین زمان تکمیل فرآیند boot وجود داشت. `cat /var/log/dmesg` را امتحان کنید. 

.

.

.

Sources:

[https://www.lifewire.com](https://www.lifewire.com)

[https://www.tecmint.com/linux-boot-process/](https://www.tecmint.com/linux-boot-process/) & [https://www.tecmint.com/best-linux-boot-loaders/](https://www.tecmint.com/best-linux-boot-loaders/)

[https://whatis.techtarget.com/definition/boot-sector](https://whatis.techtarget.com/definition/boot-sector) & [https://whatis.techtarget.com/definition/Master-Boot-Record-MBR](https://whatis.techtarget.com/definition/Master-Boot-Record-MBR)

[https://www.ibm.com/developerworks/library/l-bootload/index.html](https://www.ibm.com/developerworks/library/l-bootload/index.html)

[https://www.interserver.net/tips/kb/what-is-lilo/](https://www.interserver.net/tips/kb/what-is-lilo/)

[https://www.linuxjournal.com/article/1166](https://www.linuxjournal.com/article/1166)

[https://www.oreilly.com/library/view/linux-in-a/0596000251/ch04s02.html](https://www.oreilly.com/library/view/linux-in-a/0596000251/ch04s02.html)

[https://www.cyberciti.biz/tips/10-boot-time-parameters-you-should-know-about-the-linux-kernel.html](https://www.cyberciti.biz/tips/10-boot-time-parameters-you-should-know-about-the-linux-kernel.html)

[https://unix.stackexchange.com/questions/89923/how-does-linux-load-the-initrd-image](https://unix.stackexchange.com/questions/89923/how-does-linux-load-the-initrd-image)

[https://developer.ibm.com/articles/l-initrd/](https://developer.ibm.com/articles/l-initrd/)[https://www.ibm.com/developerworks/community/blogs/mhhaque/entry/anatomy_of_the_initrd_and_vmlinuz?lang=en](https://www.ibm.com/developerworks/community/blogs/mhhaque/entry/anatomy_of_the_initrd_and_vmlinuz?lang=en)

[http://www.linuxfromscratch.org/blfs/view/svn/postlfs/initramfs.html](http://www.linuxfromscratch.org/blfs/view/svn/postlfs/initramfs.html)

[https://help.ubuntu.com/community/Grub2](https://help.ubuntu.com/community/Grub2)

[https://www.tecmint.com/systemd-replaces-init-in-linux/](https://www.tecmint.com/systemd-replaces-init-in-linux/)

[https://fossbytes.com/systemd-vs-sys-v-vs-upstart/](https://fossbytes.com/systemd-vs-sys-v-vs-upstart/)

[https://unix.stackexchange.com/questions/196166/how-to-find-out-if-a-system-uses-sysv-upstart-or-systemd-initsystem](https://unix.stackexchange.com/questions/196166/how-to-find-out-if-a-system-uses-sysv-upstart-or-systemd-initsystem)

[https://www.tecmint.com/dmesg-commands/](https://www.tecmint.com/dmesg-commands/) 

 [https://www.linuxtechi.com/10-tips-dmesg-command-linux-geeks/](https://www.linuxtechi.com/10-tips-dmesg-command-linux-geeks/)

[https://www.quora.com/What-is-a-ring-buffer-in-Linux](https://www.quora.com/What-is-a-ring-buffer-in-Linux)

[https://unix.stackexchange.com/questions/191560/difference-between-output-of-dmesg-and-content-of-var-log-dmesg](https://unix.stackexchange.com/questions/191560/difference-between-output-of-dmesg-and-content-of-var-log-dmesg)
